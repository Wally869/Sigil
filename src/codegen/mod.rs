pub mod builder_gen;
pub mod render_gen;
pub mod struct_gen;

use crate::error::Result;
use crate::semantic::AnalyzedPrompt;

/// Generate complete Rust code from analyzed prompt
pub fn generate(analyzed: &AnalyzedPrompt) -> Result<String> {
    let mut code = String::new();

    // Add file header comment
    code.push_str("// This file was generated by Sigil. Do not edit manually.\n\n");

    // Generate the main struct
    code.push_str(&struct_gen::generate_struct(analyzed));

    // Generate the builder
    code.push_str(&builder_gen::generate_builder(analyzed));

    // Generate render methods
    code.push_str(&render_gen::generate_render_methods(analyzed));

    Ok(code)
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::lexer;
    use crate::parser;
    use crate::semantic;

    fn compile_source(source: &str) -> Result<String> {
        let tokens = lexer::lex(source)?;
        let ast = parser::parse(tokens, "test.sigil")?;
        let analyzed = semantic::analyze(&ast)?;
        generate(&analyzed)
    }

    #[test]
    fn test_generate_complete_prompt() {
        let source = r#"
@prompt Greeting
@description "A simple greeting prompt"

@message
Hello, {name}!
@end
"#;

        let code = compile_source(source).unwrap();

        // Check all major components are present
        assert!(code.contains("pub struct Greeting"));
        assert!(code.contains("pub name: String"));
        assert!(code.contains("pub struct GreetingBuilder"));
        assert!(code.contains("pub fn builder() -> GreetingBuilder"));
        assert!(code.contains("pub fn render_xml(&self) -> String"));
        assert!(code.contains("pub fn render_markdown(&self) -> String"));
        assert!(code.contains("pub fn render_plain(&self) -> String"));
    }

    #[test]
    fn test_generate_with_optional_section() {
        let source = r#"
@prompt Test

@required
Required: {value}
@end

@optional[optional]
Optional: {opt}
@end
"#;

        let code = compile_source(source).unwrap();

        assert!(code.contains("pub value: String"));
        assert!(code.contains("pub opt: Option<String>"));
        assert!(code.contains("if self.opt.is_some()"));
    }

    #[test]
    fn test_generate_with_list() {
        let source = r#"
@prompt Test

@items
Tasks:
{tasks:list}
@end
"#;

        let code = compile_source(source).unwrap();

        assert!(code.contains("pub tasks: Vec<String>"));
        assert!(code.contains("pub fn add_tasks(mut self, item: impl Into<String>) -> Self"));
        assert!(code.contains("for item in &self.tasks"));
    }

    #[test]
    fn test_generated_code_structure() {
        let source = r#"
@prompt Example
@description "Test prompt"

@section
{text}
@end
"#;

        let code = compile_source(source).unwrap();

        // Verify the structure of generated code
        let lines: Vec<&str> = code.lines().collect();

        // Should have header comment
        assert!(lines[0].contains("generated by Sigil"));

        // Should have proper ordering: struct, builder, render methods
        let struct_pos = code.find("pub struct Example").unwrap();
        let builder_pos = code.find("pub struct ExampleBuilder").unwrap();
        let render_pos = code.find("pub fn render_xml").unwrap();

        assert!(struct_pos < builder_pos);
        assert!(builder_pos < render_pos);
    }
}
