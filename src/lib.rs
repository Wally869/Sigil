// Sigil - A Domain-Specific Language for Type-Safe LLM Prompt Templates
//
// This library provides a compile-time DSL for creating type-safe prompt templates
// with multiple output formats (XML, Markdown, Plain Text).

pub mod error;
pub mod lexer;
pub mod parser;
pub mod semantic;
pub mod codegen;
pub mod util;

use std::fs;
use std::path::{Path, PathBuf};

pub use error::{SigilError, Result, SourceLocation, Span};

/// Main entry point for compiling a Sigil file
///
/// # Arguments
/// * `path` - Path to the .sigil file
///
/// # Returns
/// * `Ok(String)` - Generated Rust code
/// * `Err(SigilError)` - Compilation error
///
/// # Example
/// ```ignore
/// let generated_code = sigil::compile_sigil_file("prompts/example.sigil")?;
/// ```
pub fn compile_sigil_file<P: AsRef<Path>>(path: P) -> Result<String> {
    let path = path.as_ref();
    let source = fs::read_to_string(path)?;
    let filename = path.to_string_lossy().to_string();

    compile_sigil(&source, &filename)
}

/// Compiles Sigil source code to Rust code
///
/// # Arguments
/// * `source` - The Sigil source code
/// * `filename` - Filename for error reporting
///
/// # Returns
/// * `Ok(String)` - Generated Rust code
/// * `Err(SigilError)` - Compilation error
pub fn compile_sigil(source: &str, filename: &str) -> Result<String> {
    // Step 1: Lexical analysis
    let tokens = lexer::lex(source)?;

    // Step 2: Parse into AST
    let ast = parser::parse(tokens, filename)?;

    // Step 3: Semantic analysis and type checking
    let analyzed = semantic::analyze(&ast)?;

    // Step 4: Generate Rust code
    let generated_code = codegen::generate(&analyzed)?;

    Ok(generated_code)
}

/// Compiles all .sigil files in a directory to Rust code
///
/// # Arguments
/// * `input_dir` - Directory containing .sigil files
/// * `output_dir` - Directory to write generated .rs files
///
/// # Returns
/// * `Ok(Vec<PathBuf>)` - List of generated .rs files
/// * `Err(SigilError)` - Compilation error
///
/// # Example
/// ```ignore
/// // In build.rs
/// sigil::compile_sigil_directory("prompts", "src/generated")?;
/// ```
///
/// This will:
/// - Recursively find all .sigil files in input_dir
/// - Compile each to a .rs file in output_dir (preserving directory structure)
/// - Generate a mod.rs file that exports all compiled prompts
pub fn compile_sigil_directory<P: AsRef<Path>>(input_dir: P, output_dir: P) -> Result<Vec<PathBuf>> {
    let input_dir = input_dir.as_ref();
    let output_dir = output_dir.as_ref();

    // Create output directory
    fs::create_dir_all(output_dir)
        .map_err(|e| SigilError::IoError { message: e.to_string() })?;

    // Find all .sigil files recursively
    let sigil_files = find_sigil_files_recursive(input_dir)?;

    let mut generated_files = Vec::new();
    let mut modules = Vec::new();

    for sigil_file in &sigil_files {
        // Get relative path from input_dir
        let relative_path = sigil_file.strip_prefix(input_dir)
            .map_err(|e| SigilError::IoError { message: e.to_string() })?;

        // Create output path with .rs extension
        let mut output_file = output_dir.join(relative_path);
        output_file.set_extension("rs");

        // Compile
        let generated_code = compile_sigil_file(sigil_file)?;

        // Create parent directories if needed
        if let Some(parent) = output_file.parent() {
            fs::create_dir_all(parent)
                .map_err(|e| SigilError::IoError { message: e.to_string() })?;
        }

        fs::write(&output_file, generated_code)
            .map_err(|e| SigilError::IoError { message: e.to_string() })?;

        generated_files.push(output_file.clone());

        // Track module name for mod.rs
        let module_name = relative_path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown")
            .to_string();
        modules.push(module_name);
    }

    // Generate mod.rs
    if !modules.is_empty() {
        generate_mod_file(output_dir, &modules)?;
    }

    Ok(generated_files)
}

fn find_sigil_files_recursive(dir: &Path) -> Result<Vec<PathBuf>> {
    let mut sigil_files = Vec::new();

    let entries = fs::read_dir(dir)
        .map_err(|e| SigilError::IoError { message: e.to_string() })?;

    for entry in entries {
        let entry = entry.map_err(|e| SigilError::IoError { message: e.to_string() })?;
        let path = entry.path();

        if path.is_dir() {
            // Recurse into subdirectories
            sigil_files.extend(find_sigil_files_recursive(&path)?);
        } else if path.extension().and_then(|s| s.to_str()) == Some("sigil") {
            sigil_files.push(path);
        }
    }

    sigil_files.sort();
    Ok(sigil_files)
}

fn generate_mod_file(output_dir: &Path, modules: &[String]) -> Result<()> {
    let mod_file = output_dir.join("mod.rs");

    let mut content = String::new();
    content.push_str("// Auto-generated by Sigil - DO NOT EDIT\n");
    content.push_str("// This file exports all compiled prompt templates\n\n");

    for module in modules {
        content.push_str(&format!("pub mod {};\n", module));
    }

    content.push_str("\n// Re-export all prompt structs for convenience\n");
    for module in modules {
        content.push_str(&format!("pub use {}::*;\n", module));
    }

    fs::write(&mod_file, content)
        .map_err(|e| SigilError::IoError { message: e.to_string() })?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_compile_simple_prompt() {
        let source = r#"
@prompt Greeting
@description "A simple greeting"

@message
Hello, {name}!
@end
"#;

        let result = compile_sigil(source, "test.sigil");
        assert!(result.is_ok(), "Should compile successfully");

        let code = result.unwrap();
        assert!(code.contains("struct Greeting"), "Should generate Greeting struct");
        assert!(code.contains("pub fn builder()"), "Should generate builder method");
    }
}
