// Compile .sigil files to Rust code
//
// Usage:
//   Single file:    cargo run --example compile_template <input.sigil> <output.rs>
//   Whole directory: cargo run --example compile_template <input_dir> <output_dir>

use sigil;
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let args: Vec<String> = env::args().collect();

    if args.len() != 3 {
        eprintln!("Usage: {} <input.sigil|input_dir> <output.rs|output_dir>", args[0]);
        eprintln!();
        eprintln!("Examples:");
        eprintln!("  Single file: {} prompts/greeting.sigil target/greeting.rs", args[0]);
        eprintln!("  Directory:   {} prompts/ src/generated/", args[0]);
        std::process::exit(1);
    }

    let input_path = Path::new(&args[1]);
    let output_path = Path::new(&args[2]);

    if input_path.is_file() {
        // Single file mode
        compile_single_file(input_path, output_path)?;
    } else if input_path.is_dir() {
        // Directory mode
        compile_directory(input_path, output_path)?;
    } else {
        eprintln!("Error: Input path does not exist: {}", input_path.display());
        std::process::exit(1);
    }

    Ok(())
}

fn compile_single_file(input_path: &Path, output_path: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("Compiling {} to {}", input_path.display(), output_path.display());

    let generated_code = sigil::compile_sigil_file(input_path)?;

    // Create parent directory if it doesn't exist
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)?;
    }

    fs::write(output_path, generated_code)?;

    println!("✓ Generated {} bytes", fs::metadata(output_path)?.len());

    Ok(())
}

fn compile_directory(input_dir: &Path, output_dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
    println!("Compiling all .sigil files from {} to {}", input_dir.display(), output_dir.display());
    println!();

    // Create output directory
    fs::create_dir_all(output_dir)?;

    // Find all .sigil files recursively
    let sigil_files = find_sigil_files(input_dir)?;

    if sigil_files.is_empty() {
        eprintln!("Warning: No .sigil files found in {}", input_dir.display());
        return Ok(());
    }

    let mut modules = Vec::new();

    for sigil_file in &sigil_files {
        // Get relative path from input_dir
        let relative_path = sigil_file.strip_prefix(input_dir)?;

        // Create output path with .rs extension
        let mut output_file = output_dir.join(relative_path);
        output_file.set_extension("rs");

        // Compile
        println!("  {} -> {}", sigil_file.display(), output_file.display());
        let generated_code = sigil::compile_sigil_file(sigil_file)?;

        // Create parent directories if needed
        if let Some(parent) = output_file.parent() {
            fs::create_dir_all(parent)?;
        }

        fs::write(&output_file, generated_code)?;

        // Track module name for mod.rs
        let module_name = relative_path
            .file_stem()
            .and_then(|s| s.to_str())
            .unwrap_or("unknown");
        modules.push(module_name.to_string());
    }

    // Generate mod.rs
    generate_mod_rs(output_dir, &modules)?;

    println!();
    println!("✓ Compiled {} files", sigil_files.len());
    println!("✓ Generated {}/mod.rs with all exports", output_dir.display());

    Ok(())
}

fn find_sigil_files(dir: &Path) -> Result<Vec<PathBuf>, Box<dyn std::error::Error>> {
    let mut sigil_files = Vec::new();

    for entry in fs::read_dir(dir)? {
        let entry = entry?;
        let path = entry.path();

        if path.is_dir() {
            // Recurse into subdirectories
            sigil_files.extend(find_sigil_files(&path)?);
        } else if path.extension().and_then(|s| s.to_str()) == Some("sigil") {
            sigil_files.push(path);
        }
    }

    sigil_files.sort();
    Ok(sigil_files)
}

fn generate_mod_rs(output_dir: &Path, modules: &[String]) -> Result<(), Box<dyn std::error::Error>> {
    let mod_file = output_dir.join("mod.rs");

    let mut content = String::new();
    content.push_str("// Auto-generated by Sigil - DO NOT EDIT\n");
    content.push_str("// This file exports all compiled prompt templates\n\n");

    for module in modules {
        content.push_str(&format!("pub mod {};\n", module));
    }

    content.push_str("\n// Re-export all prompt structs for convenience\n");
    for module in modules {
        content.push_str(&format!("pub use {}::*;\n", module));
    }

    fs::write(&mod_file, content)?;

    Ok(())
}
